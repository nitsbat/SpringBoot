D in SOLID principle stands for Dependency Inversion
It states that the high level modules should not depend upon the low level modules. the decoupling of software modules should be there.
For example in the below code,
public class WindowsMachine {

    private final StandardKeyboard keyboard;
    private final Monitor monitor;

    public WindowsMachine() {
        monitor = new Monitor();
        keyboard = new StandardKeyboard();
    }

}
we have tightly coupled these three classes, Windows98Machine,Monitor and StandardKeyboard by calling new method. Now in future if we have suppose ComplexKeyboard
which is a child class of StandardKeyboard and we have arise in that situation to use that keyboard for Windows Machine. We wont be able to do that as we have tightly
coupled these. Hence we have to separate the creation of objects for this classes and just inject it into the WindowsMachine like below.
public class WindowsMachine {

    private final StandardKeyboard keyboard;
    private final Monitor monitor;

    public WindowsMachine(StandardKeyboard keyboard, Monitor monitor) {
        this.monitor = monitor;
        this.keyboard = keyboard;
    }
}

this is known as Dependency Injection. When a class suppose Class A uses some functionality of class B, then it is said that A is dependent on B. But before we can
use class B functionality , we have to create its instance and hence transfering the task of creating the object to someone else and directly using that 
dependecy is called dependency injection.
Letâ€™s say we have a car class which contains various objects such as wheels, engine, etc.
Here the car class is responsible for creating all the dependency objects.
Now, what if we decide to ditch MRFWheels in the future and want to use Yokohama Wheels?
We will need to recreate the car object with a new Yokohama dependency. But when using dependency injection (DI), we can change the Wheels at runtime (because dependencies can be injected at runtime rather than at compile time).

So Spring framework is basically an application framework used for developing java application but can be used with extensions to develop web applications.
It provides the Dependency Injection to the application.

************** UNDERSTANDING SPRING BEAN FACTORY ****************************

spring is actually called a container. A container of Beans. here beans can be referred as objects. so the role of conatiner is to create the object, handles its
lifecycle, destroying it, and using its methods. 
So if we say that class A has a dependency on class B and now in class A, for using class B we have to create a new object by calling "new ClassB()",
so this new ClassB() will be done by the spring bean factory. Now spring bean factory can be seen as a class implementing the factory pattern, which means
this class will be responsible of creating objects/beans for any class which ask for a dependecny object. but this bean factory must also have the information
about the objects or beans right, so it take configurations from spring.xml file.

************ Instantiate and Using Bean FACTORY *****************

we can use BeanFactory interface to create beans. Refer DrawingApp present in D:\Tech and Projects\Learnings\Spring Framework\SpringBoot\src\drawing
or just do git checkout b05a862360f17b37b6741dd5cfa603725eef427a

************** Application Context and member variable or Property Injection *********

we can use ApplicationContext instead of BeanFactory which is also an interface to create beans. It can be said as big brother of BeanFactory but also provide 
aome additional functionalities.
or just do git checkout 366e9b74845b6b5697dd567026c6530e9400ce14

************** Constructor Injection *********

by using properties tag in sprint.xml, we are using the setter of the class to put the value in the member variable
but we can do the same by using constructor and it has more options.
just checkout using command - git checkout 5532768699117b89e1788aa3b8e39c48e46b1907.

***************** Objects Injection ******************** 

we can inject objects in the same way, but we have to make a bean for that particular object class.
Then we have to inject that particular bean using the name as same of member variable and instead of value, we can give "ref" of previously class
object bean. 
refer - https://www.youtube.com/watch?v=g15RcFyEcrk&list=PLC97BDEFDCDD169D7&index=7

**************** Inner Beans & aliases**************************

Inner bean is actually a bean inside a bean which generally represents when there is a bean which needs to be isolated and should not be a common bean.
e.g - in triabgle example Point zero can be a common bean as it is same for any shape(rectangle,circle,etc) nut the the other two points, Point A and Point B
are separate and is specific to triangle so we can insert them inside the triangle bean only.
so the bean which is specific to a parent bean can be said as nested bean. No performance issue is there , in both cases the scenario is same,
its just for the naming to consolidate the bean with the names.

We can also give aliases to a specific bean by using alias="triangle-alias", so we can use this aliases in place of bean id's. 
the alias can be given directly in the bean definition by using name="triangle-name".
So its possible to have many aliases for a particular bean, But its always a good practice to use the bean ids instead of aliases cozz we can have unique id for a bean while aliases can be many/repeated.

so now in the ref tag, the value can be either name, bean id or alias. so to restrict this we can just use the idref which means the value in ref tag can only be id.


**************** Initialising Collections (List,Map,Set)**************************

if we want to populate a list, spring provides the list tag and we can just use in the property
 <property name="list">
            <list>
                <bean id="pointC" class="drawing.Point">
                    <property name="x" value="100"/>
                    <property name="y" value="100"/>
                </bean>
                <ref bean="pointA"/>
                <ref bean="pointB"/>
            </list>
        </property>