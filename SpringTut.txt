D in SOLID principle stands for Dependency Inversion
It states that the high level modules should not depend upon the low level modules. the decoupling of software modules should be there.
For example in the below code,
public class WindowsMachine {

    private final StandardKeyboard keyboard;
    private final Monitor monitor;

    public WindowsMachine() {
        monitor = new Monitor();
        keyboard = new StandardKeyboard();
    }

}
we have tightly coupled these three classes, Windows98Machine,Monitor and StandardKeyboard by calling new method. Now in future if we have suppose ComplexKeyboard
which is a child class of StandardKeyboard and we have arise in that situation to use that keyboard for Windows Machine. We wont be able to do that as we have tightly
coupled these. Hence we have to separate the creation of objects for this classes and just inject it into the WindowsMachine like below.
public class WindowsMachine {

    private final StandardKeyboard keyboard;
    private final Monitor monitor;

    public WindowsMachine(StandardKeyboard keyboard, Monitor monitor) {
        this.monitor = monitor;
        this.keyboard = keyboard;
    }
}

this is known as Dependency Injection. When a class suppose Class A uses some functionality of class B, then it is said that A is dependent on B. But before we can
use class B functionality , we have to create its instance and hence transfering the task of creating the object to someone else and directly using that 
dependecy is called dependency injection.
Letâ€™s say we have a car class which contains various objects such as wheels, engine, etc.
Here the car class is responsible for creating all the dependency objects.
Now, what if we decide to ditch MRFWheels in the future and want to use Yokohama Wheels?
We will need to recreate the car object with a new Yokohama dependency. But when using dependency injection (DI), we can change the Wheels at runtime (because dependencies can be injected at runtime rather than at compile time).

So Spring framework is basically an application framework used for developing java application but can be used with extensions to develop web applications.
It provides the Dependency Injection to the application.

************** UNDERSTANDING SPRING BEAN FACTORY ****************************

spring is actually called a container. A container of Beans. here beans can be referred as objects. so the role of conatiner is to create the object, handles its
lifecycle, destroying it, and using its methods. 
So if we say that class A has a dependency on class B and now in class A, for using class B we have to create a new object by calling "new ClassB()",
so this new ClassB() will be done by the spring bean factory. Now spring bean factory can be seen as a class implementing the factory pattern, which means
this class will be responsible of creating objects/beans for any class which ask for a dependecny object. but this bean factory must also have the information
about the objects or beans right, so it take configurations from spring.xml file.

************ Instantiate and Using Bean FACTORY *****************

we can use BeanFactory interface to create beans. Refer DrawingApp present in D:\Tech and Projects\Learnings\Spring Framework\SpringBoot\src\drawing
or just do git checkout b05a862360f17b37b6741dd5cfa603725eef427a

************** Application Context and member variable or Property Injection *********

we can use ApplicationContext instead of BeanFactory which is also an interface to create beans. It can be said as big brother of BeanFactory but also provide 
aome additional functionalities.
or just do git checkout 366e9b74845b6b5697dd567026c6530e9400ce14

************** Constructor Injection *********

by using properties tag in sprint.xml, we are using the setter of the class to put the value in the member variable
but we can do the same by using constructor and it has more options.
just checkout using command - git checkout 5532768699117b89e1788aa3b8e39c48e46b1907.

***************** Objects Injection ******************** 

we can inject objects in the same way, but we have to make a bean for that particular object class.
Then we have to inject that particular bean using the name as same of member variable and instead of value, we can give "ref" of previously class
object bean. 
refer - https://www.youtube.com/watch?v=g15RcFyEcrk&list=PLC97BDEFDCDD169D7&index=7

**************** Inner Beans & aliases**************************

Inner bean is actually a bean inside a bean which generally represents when there is a bean which needs to be isolated and should not be a common bean.
e.g - in triabgle example Point zero can be a common bean as it is same for any shape(rectangle,circle,etc) nut the the other two points, Point A and Point B
are separate and is specific to triangle so we can insert them inside the triangle bean only.
so the bean which is specific to a parent bean can be said as nested bean. No performance issue is there , in both cases the scenario is same,
its just for the naming to consolidate the bean with the names.

We can also give aliases to a specific bean by using alias="triangle-alias", so we can use this aliases in place of bean id's. 
the alias can be given directly in the bean definition by using name="triangle-name".
So its possible to have many aliases for a particular bean, But its always a good practice to use the bean ids instead of aliases cozz we can have unique id for a bean while aliases can be many/repeated.

so now in the ref tag, the value can be either name, bean id or alias. so to restrict this we can just use the idref which means the value in ref tag can only be id.


**************** Initialising Collections (List,Map,Set)**************************

if we want to populate a list, spring provides the list tag and we can just use in the property
 <property name="list">
            <list>
                <bean id="pointC" class="drawing.Point">
                    <property name="x" value="100"/>
                    <property name="y" value="100"/>
                </bean>
                <ref bean="pointA"/>
                <ref bean="pointB"/>
            </list>
        </property>
		
************* AUTOWIRING In Spring *****************************

Autowiring is a shotcut or a process of reducing the configuration given in the settings file i.e spring.xml
It allows us to inject objects implicitly. i.e spring uses getter and setter internally to populate that object.
Autowiring should not be used with string and primitive data types, it works greatly with the reference type.
Three types of autowiring is possible : 
byName	The byName mode injects the object dependency according to name of the bean. In such case, property name and bean name must be same. It internally calls setter method.
byType	The byType mode injects the object dependency according to type. So property name and bean name can be different. It internally calls setter method.
		It is basically useful when there will be only single member variable of a particular primitive or reference data type.
constructor	The constructor mode injects the dependency by calling the constructor of the class. It calls the constructor having large number of parameters.

*************** Spring Bean scopes ***********************************

we know that spring is providing us the beans by instantiating and configuring them in the file with our given values.
we have objects/beans in the spring container which means that whenever an object can reference another object by providing the id and spring will give an 
instance. This is done by the Spring Bean factory.

Now by default what happens in Spring BEan factory is that when applicationContext/BeanFactory is initialised , it will read the spring.xml and create all the 
beans present in that xml file. This is done before we do the getBean() operation. Hence after all the bean initialised, when any object will getBean() from 
the applicationContext it will provide the instantiated bean to the object. 

There are two bean scopes in the Spring : 

1) Singleton - Single bean per Spring container. All the thing happened as mentioned above by default.
			   It means that whenever the application context will initialise all the beans from spring.xml, it will create only instance per bean
			   and despite of having more than one call to that bean i.e getBean(), it gonna return only that instantiated bean everytime.
			   The default scope is singleton if we do not configure it.
			   Singleton here means only one instance of a bean in a spring container.
			   Different spring containers can have another single instance of that bean.
			   So one instance per bean.
			   
2) Prototype - So if we give prototype to spring, so whenever we getBean() from the applicationContext, the new bean created with every request and reference.
			   By default no bean is generated when we create applicationContext and new bean is created only when we do getBean(). not at the starting initialisation of the applicationContext.
			   
Similarly Spring has Web-aware context bean scope in which Every new bean is created per servlet request. i.e for every Api request or for every new session.

*************** Using ApplicationContextAware interface *****************************

There are some cases in spring when you need to access the applicationContext inside a bean. e.g if your bean needs to look for other beans, it will need an 
applicationcontext and hence the context needs to be injected. hence you can do getBean() inside a bean without making a new ApplicationContext.
Spring provides an ApplicationContextAware interface that allows beans access to the ApplicationContext. This interface provides a single setApplicationContext method. In this you can inject or set the applicationcontext. As soon  as the particular bean is created the current context will also get injected.
The preceding setApplicationContext() is a callback that supplies the context of the bean.

suppose in triangle class only i want a bean of Point class or some file resource bean then there will be no way to provide context in that triangle bean.
and we dont want to create a new application context for getting a new bean. Hence we have to inject the context in some way and as a result we have to use the
interface.So whenever a new bean is created of a particular class, the spring automatically assigns the context in that bean and from there we can access any bean using getBEan().


Similarly there is this BeanNameAware Interface which is implemented by beans that need access to its name defined in the Spring container.
This interface provides the setBeanName() method.
The preceding setBeanName() is a callback that supplies the name of the bean.

**************************** Bean Definition Inheritance ************************************
sometimes we have to use the beans which are repeatedly defined. So there is strategy of inheriting bean from the parent bean. This result in getting the 
properties of the parent bean and also add our functionality maybe by overriding the parent bean property.
Special property comes when bean contains the list/set. we have the ability of merging the parent bean property(list/set) with the inheritng one.
<list merge="true">

Also if we just want a simple more abstract of creating bean definition inheritance. we can just make that paritcular parent bean as abstract.
By making a bean abstract the spring doesn't make a bean for that particular bean id. It will be just used for reference and inheritance.

************************ LifeCycle Callbacks **************************

Spring also provides the callbacks ethod before initialising a bean and also after destroying the bean.
so the methods during initialisation will be sent a callback method to the bean creation.

So before seeing the method lets just see how the bean is destroyed. cozz bean are not destroyed if we make them through ApplicationContext.
We have to use AbstractApplicationContext. so using this we can close the context and detroy all beans.
If we use context.registerShutdownHook();, it will close the context and will give a shutdown hook to the context. It will destroy all the beans 
as soon as the program ends.
Now initially if we want to do something before the bean creates we can just initialise it using InitializingBean interface and then 
overriding the afterPropertiesSet() method to do something.
and for doing something before destroying a bean will be by using DisposableBean and override destroy method.
But the disadvantage is that we need to implement two particular interface and it is dependent on spring,
No dependencies should be there on concrete classes.

So to avoid this we will use in-built argument in bean decalaration and just pass the method as parameter.
the method needs to be implement in that class (of particular bean).

Now if we have any standard or functionality to use the init and destroy method for all the beans , then we dont have to define the init and destroy for all the beans . instead we can just define these two inbuilt methods at global level.
So before initialising and destroying any bean at global level it will search for these method in the pojo or concrete classes.
Now also if we define the creating/destroying by both the methods explained above, the Initialising/Disposable interface will take priority.


************************** BEAN POST PROCESSOR **********************

They are the classes that tells spring to do something after bean initialisation. it is used to extend the functionality of beans in spring.
1) The single method runs for every bean intialised no matter how many types of beans we have.
2) The BeanPostPRocessor is a separte class as we will have a same method to run after beans intialisation.

git checkout 2ebd1684

BEAN FACTORY POST PROCESSOR.
Remember that applicationContext is also a bean factory. 
so if we have a bean factory post processor, then first the bean factory post processor is called and then bean factory(ApplicationContext) is initialised
and then all the singletons beans are created.

One example of is PropertyPlaceHolder Configurer.
It is the spring made BEAN FACTORY POST PROCESSOR. and it is used for example if you want to assign the numeric or direct values of your spring.xml from
a properties file, i.e to get the hardcore values from some configuration file.

Just check the example in project how to use this processor and placeholder.
git checkout d2dc27c0

****************************** CODING TO INTERFACES ***********************************

coding to interfaces means when we are doing getBean() and just type casting into the return object. Instead of that class object we shoud use
interface.so that there will be abstraction at that point.

**************************  Introduction to Annotations and the Required Annotation **************

Spring provide many annotations to give functionality.
One such is Required annotation. suppose if we are creating a bean and we didn't provide the value to its variable or property, then
what happen will be like at runtime when spring comes to create that bean with that propery it will throw the nullPointer exception.
and that too the excpetion comes when the method using that variable will be used. I simple application its very simple but in complex situations where that method is used by 100 classes it would be difficult to find out which class method throws that exception.
as a result we as a programmer wants this exception to catch at the beginning during initialisation of bean or when contextAware is 
created.
Hence we can use the @Required annotation to the setter of that member variable and initiate the postProcessor.
why postprocessor bcoz spring actually will check that if that variable is having value during the postprocessing.

*********  The Autowired Annotation *******************

we know what autowire is, it automatically autowires the bean either through its id or type.
we can autowire using annotation also, by giving the annotation to the setter of the member variable.
Also like @Required annotation, @Autowire annotation also requires to call a postProcessor. 
if more than two properties are related to the same class,
spring first sees the type of all the beans, if there are more than two , then it will check whether the id name is matching
the member variable name, and is that also is same/different then we can distinguish the bean using @qualifier and give a qualifier tag giving
the name same as that of the annotation.



